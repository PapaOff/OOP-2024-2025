##  **Още за файлове**
`peek()` -> Връща следващия символ без да мести get-указателя <br>
`.put(char ch)` -> Поставя един символ на позицията, на която е put указателя и премества put указателя с една позиция<br>
`file << std::flush` -> Записва информацията от буфера в потока. Потоците за писане имат буфери, в които пазят информацията и в даден момент я изпращат към самия поток. По този начин се оптимизира писането в потоци. Ползва се, когато искате незабавно да запишете информацията в потока и да се предпазите от изгубване на важна информация, ако програма крашне <br>
`std::remove(filename)` -> Опитва се да изтрие файла. Връща 0 при успех<br>
`std::rename(oldName, newName))` -> Преименува файл. Връща 0 при успех<br>

##  **Основни принципи на ООП**
*	**Абстракция** - скриване на ненужни детайли
*	**Енкапсулация** - ограничаване на достъпа до данни
*	**Наследяване** - използване на вече съществуващи класове
*	**Полиморфизъм** - различни поведения чрез един интерфейс

##  **Класове и обекти**
*	**Какво е клас?** - шаблон за създаване на обекти
*	**Какво е обект?** - конкретна инстанция на клас

##  **Създаване на обекти**
```
Car c1;           // Дефолтен конструктор
Car c2 = {"BMW", 2018};  // Списък с инициализация
Car c3{"Ford", 2022};    // от C++11
```

##  **Енкапсулация**
*	**public** - достъп в класа и отвън
*	**private** - достъп само в класа
*	**protected** - достъп в класа и от наследници

##  **Гетъри и Сетъри**
`Гетърите (getters) и сетърите (setters) са методи, които осигуряват контролиран достъп до private или protected членове на клас. Те са част от принципа енкапсулация.`

**Кога да използваме гетъри и сетъри**
*	Когато трябва да контролираме достъпа до променливи
*	Когато искаме да валидираме входни стойности
*	Ако ще рефакторираме кода в бъдеще, гетъри/сетъри правят това по-лесно

##  **Разделна компилация**
`Разделната компилация (separate compilation) е техника, при която кодът се разделя на множество файлове (.h и .cpp). 
 Това позволява по-бърза компилация – компилаторът обработва само променените файлове и по-добра организация на кода – 
 улеснява управлението на големи проекти.`

##  **Основна структура на разделната компилация**
*	**Заглавни файлове (.h)** - съдържат декларации на функции и класове
*	**Файлове с изходен код (.cpp)** - съдържат реалната имплементация

**Пример:**
`Car.h ( Заглавен файл )`

```
#pragma once

class Car {
private:
    char* brand;
    int year;

public:
    void setBrand(const char* newBrand);
    const char* getBrand() const;
    void setYear(int newYear);
    int getYear() const;
    void display() const;
};
```


`Car.cpp ( Файл с имплементация )`

```
#include "Car.h"
#include <iostream>
#include <cstring>

void Car::setBrand(const char* newBrand) {
    delete[] brand;  // Освобождаваме старата памет
    brand = new char[std::strlen(newBrand) + 1];
    std::strcpy(brand, newBrand);
}

const char* Car::getBrand() const {
    return brand;
}

void Car::setYear(int newYear) {
    if (newYear > 1885 && newYear <= 2025) {
        year = newYear;
    }
}

int Car::getYear() const {
    return year;
}

void Car::display() const {
    std::cout << "Brand: " << brand << ", Year: " << year << std::endl;
}
```

> [!NOTE]
> Включваме Car.h, за да знаем как изглежда класът


`main.cpp`

```
#include "Car.h"

int main() {
    Car myCar;
    myCar.setBrand("Toyota");
    myCar.setYear(2016);
    myCar.display();
    
    return 0;
}
```

##  **Гардове в С++**
`Когато използваме заглавни файлове (.h) в C++, трябва да предотвратим многократното им включване, 
 за да избегнем грешки при компилация. Това се постига чрез гардове.`

**Това е традиционният начин за защита на заглавни файлове**
```
#ifndef CAR_H   // Ако CAR_H не е дефиниран
#define CAR_H   // Дефинираме CAR_H

class Car {
    // Дефиниция на класа
};

#endif // CAR_H
```

**Как работи?**
- Ако CAR_H не е дефиниран, компилаторът дефинира CAR_H и включва съдържанието на файла
- Ако файлът бъде включен повторно, CAR_H вече е дефиниран и кодът не се добавя пак

**Предимства**
- Поддържан навсякъде, стандартен за C++
- Работи с всички компилатори


**Това е по-модерен начин)**
```
#pragma once

class Car {
    // Дефиниция на класа
};
```

**Как работи?**
- Компилаторът запомня, че файлът вече е включен, и не го обработва отново

**Предимства**
- По-бърз от #ifndef, защото не прави макросни проверки
- По-лесен за писане – не изисква уникален идентификатор (CAR_H)


#  **Бонус**

##  **Namespace**
`В C++ namespace се използва за групиране на идентификатори (функции, класове, променливи) в отделен контекст, за да се избегнат конфликти с други части на кода`

###  **Защо се използва namespace?**
Когато работим с големи проекти или библиотеки, различни разработчици могат да създадат функции/класове със същите имена. Пространствата от имена предотвратяват този проблем

**Пример без namespace**
```
#include <iostream>

int printMessage() { return 10; }


int main() {
    int printMessage = 5; // Конфликт: функцията и променливата имат едно и също име!
    return 0;
}
```

**Пример с namespace**
```
#include <iostream>

namespace MyNamespace {
    int printMessage() { return 10; } // Сега функцията е в MyNamespace
}

int main() {
    int printMessage = 5; // Вече няма конфликт, защото функциите са в различни пространства от имена
    return 0;
}

```

###  **Деклариране и използване на namespace**
```
#include <iostream>

namespace MyNamespace {
    void sayHello() {
        std::cout << "Hello from MyNamespace!" << std::endl;
    }
}

int main() {
    MyNamespace::sayHello(); // Достъп чрез ::
    return 0;
}
```

###  **using namespace – Премахване на нуждата от ::**
Ако не искаме постоянно да пишем MyNamespace::, можем да използваме using namespace

```
using namespace MyNamespace; // Вече не е нужно да пишем MyNamespace::

int main() {
    sayHello(); // Директен достъп
    return 0;
}
```
> [!NOTE]
> Недостатък: Ако има конфликт на имена с друга библиотека (например std), може да получим грешки


##  **using за конкретни членове**
Ако не искаме да използваме цялото пространство от имена, а само определени елементи, използваме using за конкретни функции или класове

```
using MyNamespace::sayHello;

int main() {
    sayHello(); // Работи без MyNamespace::
    return 0;
}
```

##  **Анонимни namespace**
Ако създадем namespace без име, той става **локален** за файла, в който е деклариран

```
namespace {
    int secretFunction() {
        return 42;
    }
}

int main() {
    std::cout << secretFunction() << std::endl; // Работи, но само в този файл
    return 0;
}
```

> [!NOTE]
> Полза: Защитава функциите от външен достъп – полезно за модули и библиотеки

##  **const**

###  **const при променливи**
Полезно за дефиниране на стойности, които не трябва да се променят

```
const int maxUsers = 10; 
maxUsers = 20; // Грешка: не може да се променя

```

###  **const при указатели**
Не можем да променяме стойността, към която сочи указателят

```
int x = 5;
const int* ptr = &x; // ptr сочи към "const int"
*ptr = 10; // Грешка: не може да променя стойността на x
x = 10;    // Позволено: x може да бъде променен директно
```

###  **Указател към константа**
Можем да променяме стойността, но указателят не може да сочи другаде

```
int x = 5;
int* const ptr = &x; // "const pointer to int"
*ptr = 10;  // Позволено: можем да променим стойността на x
ptr = &y;   // Грешка: указателят не може да сочи другаде
```

###  **Константен указател към константа**
Нито стойността, нито указателят могат да бъдат променени

```
const int x = 5;
const int* const ptr = &x; // const pointer to const int
*ptr = 10; // Грешка: не можем да променим стойността
ptr = &y;  // Грешка: не можем да пренасочваме указателя
```

###  **const при параметри на функции**
Предотвратява промяната на подадения аргумент вътре в функцията

```
void printMessage(const char* message) {
    // message[0] = 'H'; Грешка: параметърът е const
    std::cout << message;
}
```

###  **const при параметри на функции**
Този метод няма право да променя speed или **други членове** на класа

```
class Car {
private:
    int speed;
public:
    int getSpeed() const { return speed; } // Гарантира, че не променя обекта
};
```