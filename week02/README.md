## **Потоци**

Поток (stream) е абстракция за последователен вход или изход на данни. Той позволява четене и запис на данни от/в различни източници като конзола, файлове или памет
D:\OOP_СИ_2024-2025\week02\1. Streams.png

## **Основни видове потоци**

Конзолни потоци (<iostream>)
`std::cin` - вход
`std::cout` - изход
`std::cerr` - грешки

Файлови потоци (<fstream>)
`std::ifstream` – четене от файл
`std::ofstream` – запис във файл
`std::fstream` – четене и запис във файл

Стрингови потоци (<sstream>)
`std::stringstream` – работа със стрингови данни

**Пример за отваряне на файл за писане**

```
    std::ofstream outFile("output.txt");
    if (!outFile.is_open()) // Винаги проверяваме дали сме отворили файла успешно
    {
        std::cerr << "Error opening file for writing!" << std::endl;
        return -1;
    }

    outFile << "Hello\nWorld\n" << "this is "; // Може да се chain-ват
    outFile << "C++\n";
    outFile.close(); // По принцип се затварят автоматично след излизане от scope, но е добра практика да ги затваряме като приключим работа с тях
```

**Пример за отваряне на файл за четене**

```
    std::ifstream inFile("output.txt");
    if (!inFile.is_open()) // Винаги проверяваме дали сме отворили файла успешно
    {
        std::cerr << "Error opening file for reading!" << std::endl;
        return -1;
    }

    const int bufferSize = 256;
    char *buffer = new char[bufferSize]; // Създаваме буфер с определен размер за четене от файла

    while (inFile.getline(buffer, bufferSize)) //getline(<къде да запише>, <колко да запише>)
    {
        std::cout << "Read line: " << buffer << std::endl;
    }

    delete[] buffer; // Важно
    inFile.close();  // Важно
```

## **Начини за отваряне на файл**

`ios::in` - Отваря файла за четене. Ако файлът не съществува, го създава
`ios::out` - Отваря файла за писане. Ако файлът съществува, изтрива съдържанието му
`ios::ate` - Отваря файла за писане като насочва указателя да сочи в края на файла
`ios::app` - Отваря файла за писане като насочва указателя да сочи в края на файла. Указателят не може да бъде преместен! Съдържанието на файла не се изтрива при отваряне
`ios::trunc` - Ако файлът съществува, изтрива съдържанието му
`ios::binary` - Отваря файла в бинарно състояние

> [!NOTE]
> Създавайки файл с std::ifstream, той по подразбиране се отваря с std::ios::in. Аналогично, отваряйки файл с std::ofstream, той по подразбиране се отваря с std::ios::out

**Примери за отваряне на файл**

```
std::fstream file("example.txt", std::ios::in); // Отваря файл само за четене

std::fstream file("example.txt", std::ios::in | std::ios::out | std::ios::app);
    // Отваря файла за четене, писане и запазва предишното съдържание и добавя нови данни в края

std::fstream file("binary_data.bin", std::ios::out | std::ios::app | std::ios::binary);
    // Отваря файла за писане, запазва предишната информация и го отваря в бинарен режим
```

## **Флагове за състояние на потока**

`std::ios` съдържа флагове (битови флагове), които указват състоянието на потока. Това са специални битове, които се вдигат при следните ситуации:
`std::ios::goodbit` -> Всичко е наред, няма грешки
`std::ios::eofbit` -> Вдига се, когато е достигнат краят на файла (EOF - End Of File)
`std::ios::failbit` -> Вдига се, когато операцията по четене или запис не е успешна, но потокът все още може да бъде използван
`std::ios::badbit` -> Вдига се при сериозен проблем с потока, като хардуерен дефект или неуспешен достъп до файлова система

> [!NOTE]
> file.clear() се използва за нулиране на флаговете за грешки в потока

**Пример**

```
void processFile(const char *filename)
{
    std::ifstream file(filename);

    if (!file.is_open())
    {
        std::cout << "Could not open the file!" << std::endl;
        return;
    }

    int number;
    while (true)
    {
        file >> number;

        if (file.eof())
        {
            std::cout << "End of file" << std::endl;
            break;
        }

        if (file.fail())
        {
            std::cout << "Invalid data. Skipping.." << std::endl;
            file.clear();            // Изчистваме грешката
            file.ignore(1000, '\n'); // Пропускаме текущия ред -> или макс 1000 символа или докато не стигнем нов ред
            continue;
        }

        if (file.bad()) // Сериозна грешка
        {
            std::cout << "Critical error while reading!" << std::endl;
            break;
        }

        std::cout << "Read number: " << number << std::endl;
    }

    file.close();
}
```

## **Указателите за четене и писане във файлов поток**

`file.seekg(numOfChars, fromWhere)` -> Мести указателя за четене на файла с numOfChars, започвайки от fromWhere
`file.tellg()` -> Връща къде се намира указателя за четене
`file.seekp(numOfChars, fromWhere)` -> Мести указателя за писане на файла с numOfChars, започвайки от fromWhere
`file.tellp()` -> Връща къде се намира указателя за писане

> [!NOTE]
> tellp() и tellg() връщат std::streampos, но могат да бъдат неявно преобразувани в int или long long (ако се работи с големи файлове, по-добре long long)

## **Четене във файл**

```
    char c;

    // Prints all the contents of the file!
    while (!inputStream.eof() && inputStream) // Въртим цикъла, докато не стигнем края на файла и потокът е валиден
    {
        c = inputStream.get();
        std::cout << c;
    }
```

Кодът горе има проблем. eof() се вдига чак когато сме се опитали да прочетем и се окаже, че е края на файла. Тоест последното ни четене ще бъде невалидно и затова най-често последния символ, който ще отпечатаме на конзолата е �. По-добър вариант за четене е следния:

```
    while (inputStream.get(c))
    {
         std::cout << c;
    }
```

## **Бинарни файлове**

Същото като нормалните файлове, но с няколко разлики:

- Името на файла трябва да завършва на .dat или .bin, а не на .txt
- Трябва да добавим `std::ios::binary`, за да отворим файла в двоичен (бинарен) режим
- Използваме функциите read() и write() за четене и запис
- `read()` и `write()` изискват 2 аргумента: <адреса в паметта>,<броя байтове, които ще запишем във файла>

> [!NOTE]
> `read()` и `write()` използват байт-ориентирани потоци, което означава, че очакват указател към сурови байтове `(char*)`. Трябва да третирате всичко като последователност от байтове
